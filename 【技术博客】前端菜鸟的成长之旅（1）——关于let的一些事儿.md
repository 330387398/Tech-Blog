&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天第一篇~就先写点基础又常用的，恰好又是前几天困扰过我的——`let`。
* 基本描述</br>`let`是ES6新引入的一条命令，它被用于声明变量，其用法与`var`类似，因此二者也经常被拿来比较和区别，相信这点应该不止困扰过我一个吧。那么引入`let`的意义何在？它比`var`好用在哪里呢？

* 块级作用域</br>要了解`let`，必须先理解块级作用域。先上代码：
```
//代码一：
{
  var a = 1;
  let b = 2;
}

a // 1
b // ReferenceError: a is not defined.
```
↑由上述代码可以看出，在代码块之中，分别用`var`和`let`声明了两个变量。然后在代码块之外调用这两个变量时，`var`声明的变量返回了正确的值，而`let`声明的变量则报错。这表明，`let`声明的变量只在它所在的代码块中有效。这就是我们所谓的作用域的概念。
```
//代码二：
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // 同样的变量!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // 不同的变量
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
```
↑上面两个函数中，各自分别有两个代码块。</br>当使用`var`声明变量时，`if`外层的 x 和内层的 x 是同一个变量，分别被赋值两次，最终`x = 2`；而使用`let`声明变量时，`if`内外层的 x 却成了两个不同的变量，各自赋值，互不影响。</br>这就是我们所谓的块级作用域。——`var`声明的变量的作用域是整个封闭函数（或全局），而`let`声明的变量只在其声明的块或子块中生效。
```
//代码三：
for (var i = 0; i < 3; i++) {
  var i = 'abc';
  console.log(i);
}
// abc

for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```
↑通过上面两段代码，我们发现，在`for`循环内部，`var`为变量 i 赋值时，覆盖了 i 本身的值，因此`for`循环只执行了一次；而使用`let`声明变量及赋值时，由于其本身只作用于自己所在的作用域，因此两个变量i各自独立，互不影响，也因此`for`循环被执行了三次。
```
//代码四：
var liList = document.querySelectorAll('li') // 共5个li
for( var i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
//5
//5
//5
//5
//5

var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
//0
//1
//2
//3
//4
```
↑通过这段代码不难看出，我们的本意是想依次输出0-4，然而在使用`var`声明变量i时，却造成了计数循环用的变量 i 泄露成为了全局变量，从而输出了5个5。</br>在这种情况下，我们只要将声明变量的方式改为`let`，就能轻易防止类似的变量泄露情况了。
```
//代码五：
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
```
↑通过最后这段代码可以看出，在程序或者函数的顶层，`let`并不会像`var`一样在全局对象上创造一个属性。或者说，由于其本身的特性，使得`let`无法声明全局变量。

* 暂存死区</br>有了块级作用域的概念，自然就衍生出了一种常见的错误情况，这种现象也被称为TDZ。</br>↓首先，在同一个函数或同一个作用域中，如果用`let`重复定义一个变量，将引起TypeError。
```
//代码一：
if (x) {
  let foo;
  let foo; // TypeError thrown.
}
```
↑上面的代码中，第一次使用`let`声明变量`foo`时，它就已经绑定了这个块级作用域，因此当再次对同一个变量进行声明时，会产生报错。
也可以将其理解为，使用`let`声明变量时，不能在同一作用域中重复声明两次或以上。
```
//代码二：
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
↑上面的代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。</br>ES6明确规定：如果区块中存在`let`命令，那么这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</br>换言之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

* 变量提升</br>我们都知道，使用`var`命令声明变量时会发生“变量提升”的现象，即变量可以在声明之前被使用，其值为`undefined`。这种现象多少是有些奇怪的，因为按照一般的逻辑，变量应该在声明语句之后才可以被使用。</br>为了纠正这种现象，`let`命令改变了语法行为，它所声明的变量一定要在声明后才能被使用，否则就会报错。
```
//代码一：
console.log(foo); // 输出undefined
var foo = 2;

console.log(bar); // 报错ReferenceError
let bar = 2;
```
↑上面的代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。而变量`bar`用`let`命令声明，在声明它之前，变量`bar`是不存在的，这时如果用到它，系统就会报错。</br>因此，很多人认为，使用`let`声明变量时，是不存在变量提升的。
### 但我本人认为这一说法是不够严谨的。
首先，在官方文档中，我并没有看到有明确说明，使用`let`声明变量不存在变量提升。因此，同时也有很多人认为关于`let`的变量提升是有争议的。</br>↓我们来看下面这段代码：
```
//代码二：
let a = 1
{
  a = 2   //Uncaught ReferenceError: a is not defined
  let a
}
```
↑如果`let`不会提升，那么`a = 2`就会将外面的 a 由 1 变成 2 ，但为什么系统会报错呢？</br>如果说`let`绑定了花括号内的块级作用域的话，为什么let能够在声明前就自动绑定整个作用域呢？</br>因此我认为，单纯地讲'let'有没有变量提升，都是不准确的。</br></br>后来，经过我对网上一些大牛写的博客的分析理解，和自己的思考，我认为可以这样理解：
1. 在我们探讨`var`提升变量时，通常把`var a = 1`拆分成两个过程，即声明（`var a`）和赋值（`a = 1`）。我们都知道，声明的行为会被提升，而赋值不会；
2. 我们可以尝试用同样的思路用来理解`let`声明变量的过程，只不过，`let`声明变量比`var`多了一个步骤，或者说，`var`声明变量的过程中有一个步骤一直被我们忽略了；
3. 我将`let`声明分为三个步骤：创建、初始化和赋值。在第1条中的声明（`var a`）可以看作创建 + 初始化，也就是说，`var`命令将创建变量和初始化变量这两个步骤提升了，而没有把赋值的步骤提升。同样的，`let`声明将创建变量的步骤提升了，而初始化变量和为变量赋值这两个步骤没有被提升。这样一来，`let`的变量声明问题就说得通了。

↓为了让这个说法更加形象可靠，我们来看下面的代码：
```
//代码三：
function fn(){
  var x = 1
  var y = 2
}
fn()
```
↑这是一段`var`声明变量的过程。在执行 fn 时，会有以下过程（不完全）：
1. 进入 fn，为 fn 创建一个环境；
2. 找到 fn 中所有用`var`声明的变量，在这个环境中「创建」这些变量（即 x 和 y）；
3. 将这些变量「初始化」为 undefined；
4. 开始执行代码；
5. x = 1 将 x 变量「赋值」为 1；
6. y = 2 将 y 变量「赋值」为 2。

也就是说，`var`声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。
这就解释了为什么在`var x = 1`之前`console.log(x)`会得到`undefined`。
```
//代码四：
fn2();

function fn2(){
  console.log(2)
}
```
↑这是`function`声明的「创建、初始化和赋值」的过程。同样会有以下过程：
1. 找到所有用`function`声明的变量，在环境中「创建」这些变量；
2. 将这些变量「初始化」并「赋值」为 function(){ console.log(2) }；
3. 开始执行代码 fn2()。

也就是说，`function`声明会在代码执行之前就「创建、初始化并赋值」。
```
//代码五：
{
  let x = 1
  x = 2
}
```
↑最后，来看看`let`声明的「创建、初始化和赋值」过程：
1. 找到所有用`let`声明的变量，在环境中「创建」这些变量；
2. 开始执行代码（现在还没有初始化）；
3. 执行`x = 1`，将 x 「初始化」为 1（这并不是一次赋值，如果代码是`let x`，就将 x 初始化为`undefined`）；
4. 执行`x = 2`，对 x 进行「赋值」。

这么一来，变量提升的问题基本可以比较清晰地解释了：
1. `let`的「创建」过程被提升了，但是初始化没有提升；
2. `var`的「创建」和「初始化」都被提升了；
3. `function`的「创建」「初始化」和「赋值」都被提升了。

以上就是目前我对`let`用法的一点浅见。如果这博客真的有人看的话，欢迎您和我联系，一起探讨技术问题，毕竟自学路上是很需要良师益友的~下周见！